[제목]
지금부터 2020년도 제 15회 E-PPER 대비 기출문제 풀이를 시작하겠습니다. 
2018년도 제 12회 E-PPER JAVA 부문 10번 문제입니다.
[문제 설명]
10번 문제는 마지막 문제인 만큼 굉장히 문제가 깁니다.
요약을 하자면 선후관계가 존재하는 작업 공정에서, 해당 공정완료까지 소요되는 최소시간을 구하는 문제입니다.
[입력 형식]
입력은 공정 수와, 관계 수가 입력됩니다.
이후 각 공정의 소요 시간들, 공정간의 관계들이 입력됩니다.
마지막으로 목표 공정 번호까지 입력됩니다.
[출력 형식]
출력은 최소 소요 시간만 int 형식으로 출력하면 됩니다.
[문제 풀이 아이디어 설명]
다음은 풀이 아이디어 입니다.
첫번째 공정을 첫번째로 시작한다는 점에서 큐를 사용할 수도 있을 것 같고, 공정의 시간을 저장하는 건 배열로 할 수 있을 것 같습니다.
이를 위해 선입선출 큐를 구현해야 하고, 배열 그리고 for나 while의 반복문을 사용할 것입니다.
가장 중요한 문제 조건에서, 공정 선후관계를 구현해야합니다. 
이를 위해 저는 공정이 진행 가능한지를 int 배열 inDegree를 사용해서 표시하고자 합니다. 
그리고 반복문에서는 실행 가능한 공정들을 큐에 넣어서 실행하는 것을 반복할 겁니다.
이때 매 공정 실행 시에 각 공정에 걸린 시간을 배열을 사용해 저장할 것입니다.
요약하자면 큐로 공정을 진행하고, 배열에 값을 저장합니다.
[코드 작성 화면]
앞선 풀이 아이디어를 바탕으로 직접 풀어보겠습니다. 
위의 주석에 있듯이, 저는 IntelliJ로 실제와 비슷한 구조를 미리 만들어 놓았습니다. 
지금까지는 오직 solution 함수 내부에만 코딩을 했습니다.
하지만 프로그래머스에서는 Solution class 외부에서 import도 진행할 수 있고, solution 함수 외의 필요하신 함수를 정의해서 사용할 수 도 있습니다. 
이번에는 다른 함수를 정의하지는 않고, 큐를 위한 LinkedList만 import하겠습니다.
다음으로 사용할 변수와 배열들이 미리 정의합니다.
n_len 변수는 n의 길이로, 공정의 개수를 저장합니다.
adj 배열은 공정간의 관계를 파라미터로 받아서 저장합니다.
time 배열은 각 공정의 소요 시간들을 저장합니다.
total 배열은 각 공정의 최소 소요 시간들을 저장합니다.
inDegree 배열은 각 공정을 시작하기 까지 몇 개의 선수 공정이 남았는지를 저장합니다.
다음으로 초기화를 진행합니다.
저는 System.arraycopy를 사용해서 time 배열에 n 배열을 복사했습니다. 
실제 시험에서는 검색이 불가능하니, 기억이 나지 않으신다면 for문을 사용하여 복사하셔도 됩니다.
그리고 선후관계를 저장하면서 inDegree 배열의 값도 갱신합니다.
지금 for문의 조건식이 생소하시면 밑의 조건식으로 변경하여 진행하셔도 무방합니다.
그리고 큐를 위한 LinkedList를 만들고 바로 진행가능한 공정을 큐에 추가해줍니다.
좀 더 자세하게 설명을 하자면, inDegree가 0이면 선수공정이 없기 떄문에 해당 공정을 바로 진행하기 위해 Queue에 추가해줍니다.
그리고 동시에, total은 각 공정의 최소 소요 시간이기 때문에 time값을 그대로 저장하면 됩니다.
이제, Queue를 사용해서 공정을 진행합니다.
저희는 Queue 진행가능한 공정을 계속해서 추가할 것이라서 Queue가 비어있는 것은 모든 공정이 끝났다는 것을 의미합니다.
따라서 while의 종료 조건을 queue.isEmpty()로 작성합니다.
여기서도, 실제 시험에서는 검색이 불가능하니까 isEmpty와 같은 method는 대소문자랑 괄호까지 외우셔야 보다 편하실 것 같습니다.
변수 q에 Queue에서 가장 먼저 입력된 값을 저장합니다. 
저는 poll()을 사용하였습니다.
q에 담긴 노드 번호가 선수 공정인 경우를 찾아서 total과 inDegree값을 갱신해야 합니다.
for문과 if문을 사용합니다.
모든 노드에 대하여 선수관계인 경우를 찾습니다.
total은, 두 가지 값을 비교해서 더 큰 값을 저장합니다. 
더 자세히 설명을 하자면, 하나의 공정에 두 개 이상의 선수관계가 있을 수 있습니다.
이때 두 공정 중 더 늦게 끝나는 것이 있다면, 그 공정을 끝낸 다음에야 진행할 수 있기 때문에 더 큰 값을 저장해야 합니다.
--inDegree를 사용해서 해당 inDegree 값을 1씩 빼주고 만약 0이면 작업을 진행하기 위해 Queue에 삽입합니다.
마지막으로, 목표한 공정의 최소 소요시간을 return합니다.
이번 문제의 경우는, total 배열의 값을 그냥 return 해도 되기 때문에 answer변수를 지워주셔도 괜찮습니다.
풀이가 조금 길었는데, 지금까지 풀이 들어주셔서 감사합니다!